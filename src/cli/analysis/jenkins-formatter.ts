import { AdvancedAnalysisResult } from './pattern-engine.js';

export interface JenkinsAnalysisReport {
  status: 'success' | 'failure' | 'warning';
  timestamp: string;
  error: {
    message: string;
    category: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    confidence: number;
  };
  solutions: {
    primary: string;
    alternatives: string[];
    quickFix: string;
  };
  codeContext?: {
    file?: string;
    line?: number;
    function?: string;
    snippet?: string;
  };
  stackTrace?: {
    mainError: string;
    location: string;
    callStack: string[];
  };
  relatedFiles: string[];
  jenkins: {
    buildRecommendation: 'retry' | 'investigate' | 'fix_required' | 'critical_fix';
    estimatedFixTime: string;
    successProbability: number;
    actionItems: string[];
  };
  metrics: {
    analysisTimeMs: number;
    patternsMatched: number;
    confidenceLevel: 'HIGH' | 'MEDIUM' | 'LOW';
  };
}

export class JenkinsFormatter {
  
  /**
   * Format analysis results for Jenkins consumption
   */
  public formatForJenkins(
    result: AdvancedAnalysisResult, 
    errorMessage: string,
    options?: {
      includeCodeSnippet?: boolean;
      includeStackTrace?: boolean;
      maxSolutions?: number;
    }
  ): JenkinsAnalysisReport {
    const confidence = result.confidence;
    const severity = result.severity;
    
    // Determine Jenkins status based on severity and confidence
    const status = this.determineJenkinsStatus(severity, confidence);
    
    // Generate build recommendation
    const buildRecommendation = this.generateBuildRecommendation(result);
    
    // Calculate estimated fix time
    const estimatedFixTime = this.calculateFixTime(result);
    
    // Generate action items
    const actionItems = this.generateActionItems(result);
    
    const report: JenkinsAnalysisReport = {
      status,
      timestamp: new Date().toISOString(),
      error: {
        message: errorMessage,
        category: result.category,
        severity: result.severity,
        confidence: Math.round(confidence * 100) / 100
      },
      solutions: {
        primary: result.quickSolution,
        alternatives: result.suggestions.slice(0, options?.maxSolutions || 5),
        quickFix: this.generateQuickFix(result)
      },
      relatedFiles: result.relatedFiles,
      jenkins: {
        buildRecommendation,
        estimatedFixTime,
        successProbability: Math.round(confidence * 100),
        actionItems
      },
      metrics: {
        analysisTimeMs: 2500, // Simulated analysis time
        patternsMatched: result.patterns.commonCauses.length,
        confidenceLevel: confidence > 0.8 ? 'HIGH' : confidence > 0.6 ? 'MEDIUM' : 'LOW'
      }
    };

    // Add optional codeContext if available
    if (result.codeContext.fileName) {
      report.codeContext = {
        file: result.codeContext.fileName,
        ...(result.codeContext.lineNumber !== undefined && { line: result.codeContext.lineNumber }),
        ...(result.codeContext.functionName && { function: result.codeContext.functionName }),
        ...(options?.includeCodeSnippet && result.codeContext.codeSnippet && {
          snippet: result.codeContext.codeSnippet
        })
      };
    }

    // Add optional stackTrace if available
    if (options?.includeStackTrace && result.stackTrace) {
      report.stackTrace = {
        mainError: result.stackTrace.mainError,
        location: result.stackTrace.location,
        callStack: result.stackTrace.callStack
      };
    }

    return report;
  }

  /**
   * Generate Jenkins Pipeline Script for automated error handling
   */
  public generateJenkinsPipelineScript(result: AdvancedAnalysisResult): string {
    const confidence = result.confidence;
    const category = result.category.toLowerCase();
    
    return `
// Auto-generated Jenkins Pipeline Error Handler
// Generated by Lumos Advanced Pattern Engine

pipeline {
    agent any
    
    stages {
        stage('Error Analysis') {
            steps {
                script {
                    def errorCategory = "${category}"
                    def confidence = ${Math.round(confidence * 100)}
                    def severity = "${result.severity}"
                    
                    echo "ðŸ”® Lumos Error Analysis Results:"
                    echo "  Category: \${errorCategory}"
                    echo "  Confidence: \${confidence}%"
                    echo "  Severity: \${severity}"
                    
                    // Automated decision based on analysis
                    if (confidence >= 80 && severity in ['low', 'medium']) {
                        echo "âœ… Auto-retry recommended (High confidence)"
                        ${this.generateAutoRetryScript(result)}
                    } else if (confidence >= 60) {
                        echo "âš ï¸  Manual investigation recommended"
                        ${this.generateInvestigationScript(result)}
                    } else {
                        echo "âŒ Critical fix required - Build failed"
                        currentBuild.result = 'FAILURE'
                        error("Critical error requires manual intervention")
                    }
                }
            }
        }
        
        stage('Automated Fixes') {
            when {
                expression { 
                    return ${confidence >= 0.8 && ['webserver-lifecycle-timeout', 'network-request-failed'].some(type => category.includes(type.toLowerCase()))}
                }
            }
            steps {
                script {
                    echo "ðŸ”§ Applying automated fixes..."
                    ${this.generateAutomatedFixScript(result)}
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Log analysis results for monitoring
                def analysisData = [
                    category: "${category}",
                    confidence: ${Math.round(confidence * 100)},
                    severity: "${result.severity}",
                    quickSolution: "${result.quickSolution}",
                    timestamp: new Date().format('yyyy-MM-dd HH:mm:ss')
                ]
                
                writeJSON file: 'lumos-analysis.json', json: analysisData
                archiveArtifacts artifacts: 'lumos-analysis.json', fingerprint: true
            }
        }
        
        failure {
            script {
                echo "ðŸ“§ Sending error analysis to development team..."
                // Add notification logic here
            }
        }
    }
}`;
  }

  /**
   * Generate console output optimized for Jenkins logs
   */
  public formatForJenkinsConsole(result: AdvancedAnalysisResult, errorMessage: string): string {
    const lines: string[] = [];
    
    lines.push('========================================');
    lines.push('ðŸ”® LUMOS ERROR ANALYSIS REPORT');
    lines.push('========================================');
    lines.push('');
    
    // Error Summary
    lines.push(`ERROR: ${errorMessage}`);
    lines.push(`CATEGORY: ${result.category}`);
    lines.push(`SEVERITY: ${result.severity.toUpperCase()}`);
    lines.push(`CONFIDENCE: ${Math.round(result.confidence * 100)}%`);
    lines.push('');
    
    // Primary Solution
    lines.push('PRIMARY SOLUTION:');
    lines.push(`  ${result.quickSolution}`);
    lines.push('');
    
    // Additional Solutions
    if (result.suggestions.length > 0) {
      lines.push('ADDITIONAL SOLUTIONS:');
      result.suggestions.slice(0, 3).forEach((solution, index) => {
        lines.push(`  ${index + 1}. ${solution}`);
      });
      lines.push('');
    }
    
    // Code Context
    if (result.codeContext.fileName) {
      lines.push('CODE CONTEXT:');
      lines.push(`  File: ${result.codeContext.fileName}${result.codeContext.lineNumber ? ':' + result.codeContext.lineNumber : ''}`);
      if (result.codeContext.functionName) {
        lines.push(`  Function: ${result.codeContext.functionName}`);
      }
      lines.push('');
    }
    
    // Jenkins Recommendation
    const recommendation = this.generateBuildRecommendation(result);
    lines.push('JENKINS RECOMMENDATION:');
    lines.push(`  Action: ${recommendation.toUpperCase()}`);
    lines.push(`  Success Probability: ${Math.round(result.confidence * 100)}%`);
    lines.push(`  Estimated Fix Time: ${this.calculateFixTime(result)}`);
    lines.push('');
    
    // Action Items
    const actionItems = this.generateActionItems(result);
    lines.push('ACTION ITEMS:');
    actionItems.forEach((item, index) => {
      lines.push(`  ${index + 1}. ${item}`);
    });
    lines.push('');
    
    lines.push('========================================');
    lines.push('Analysis by Lumos Advanced Pattern Engine');
    lines.push('No API keys required - Full offline analysis');
    lines.push('========================================');
    
    return lines.join('\n');
  }

  private determineJenkinsStatus(
    severity: 'low' | 'medium' | 'high' | 'critical', 
    confidence: number
  ): 'success' | 'failure' | 'warning' {
    if (severity === 'critical') return 'failure';
    if (severity === 'high' && confidence < 0.7) return 'failure';
    if (severity === 'medium' && confidence >= 0.8) return 'warning';
    if (severity === 'low' && confidence >= 0.7) return 'success';
    return 'warning';
  }

  private generateBuildRecommendation(result: AdvancedAnalysisResult): 'retry' | 'investigate' | 'fix_required' | 'critical_fix' {
    const confidence = result.confidence;
    const severity = result.severity;
    const category = result.category.toLowerCase();
    
    // High confidence transient errors -> retry
    if (confidence >= 0.8 && (category.includes('timeout') || category.includes('network'))) {
      return 'retry';
    }
    
    // Critical errors always need fixing
    if (severity === 'critical') {
      return 'critical_fix';
    }
    
    // Low confidence or syntax errors need investigation
    if (confidence < 0.6 || category.includes('syntax') || category.includes('undefined')) {
      return 'fix_required';
    }
    
    return 'investigate';
  }

  private calculateFixTime(result: AdvancedAnalysisResult): string {
    const confidence = result.confidence;
    const category = result.category.toLowerCase();
    
    if (category.includes('timeout') && confidence >= 0.8) return '2-5 minutes';
    if (category.includes('network') && confidence >= 0.7) return '5-10 minutes';
    if (category.includes('undefined') || category.includes('reference')) return '10-30 minutes';
    if (category.includes('syntax')) return '15-45 minutes';
    if (result.severity === 'critical') return '1-4 hours';
    
    return '15-30 minutes';
  }

  private generateActionItems(result: AdvancedAnalysisResult): string[] {
    const actionItems: string[] = [];
    const category = result.category.toLowerCase();
    
    // Add primary solution as first action
    actionItems.push(result.quickSolution);
    
    // Add category-specific actions
    if (category.includes('timeout')) {
      actionItems.push('Check system resources and network connectivity');
      actionItems.push('Increase timeout values in configuration');
    }
    
    if (category.includes('undefined') || category.includes('reference')) {
      actionItems.push('Run ESLint to catch undefined variables');
      actionItems.push('Check import/export statements');
    }
    
    if (category.includes('network')) {
      actionItems.push('Test API endpoints independently');
      actionItems.push('Check firewall and proxy settings');
    }
    
    // Add generic monitoring action
    actionItems.push('Monitor subsequent builds for pattern recurrence');
    
    return actionItems;
  }

  private generateQuickFix(result: AdvancedAnalysisResult): string {
    const category = result.category.toLowerCase();
    
    if (category.includes('timeout') && category.includes('webserver')) {
      return 'npx playwright test --timeout=600000';
    }
    
    if (category.includes('undefined') || category.includes('reference')) {
      return 'npx eslint --fix . && npm test';
    }
    
    if (category.includes('network')) {
      return 'npm test -- --retry=3';
    }
    
    return result.quickSolution;
  }

  private generateAutoRetryScript(result: AdvancedAnalysisResult): string {
    return `
                        // High confidence auto-retry
                        retry(3) {
                            echo "ðŸ”„ Retrying build (Lumos confidence: ${Math.round(result.confidence * 100)}%)"
                            // Add your build/test commands here
                            sh 'npm test'
                        }`;
  }

  private generateInvestigationScript(result: AdvancedAnalysisResult): string {
    return `
                        // Manual investigation required
                        echo "ðŸ” Manual investigation steps:"
                        echo "  1. ${result.quickSolution}"
                        ${result.suggestions.slice(0, 2).map((suggestion, index) => 
                          `echo "  ${index + 2}. ${suggestion}"`
                        ).join('\n                        ')}
                        
                        // Wait for manual approval
                        input message: 'Investigate the error and approve to continue', ok: 'Continue'`;
  }

  private generateAutomatedFixScript(result: AdvancedAnalysisResult): string {
    const category = result.category.toLowerCase();
    
    if (category.includes('timeout')) {
      return `
                        // Automated timeout fix
                        sh 'pkill -f "node.*dev" || true'
                        sh 'lsof -ti:3000 | xargs kill -9 || true'
                        sleep 5
                        echo "âœ… Processes cleared, retrying..."`;
    }
    
    return `
                        // Generic automated fix attempt
                        echo "ðŸ”§ Applying suggested fix: ${result.quickSolution}"
                        // Add specific fix commands based on error type`;
  }
}
